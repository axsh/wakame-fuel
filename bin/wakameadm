#!/usr/bin/env ruby

require File.dirname(__FILE__) + '/../config/boot'

require 'rubygems'
require 'optparse'
require 'drb/drb'

require 'erb'

require 'wakame'
require 'wakame/util'

class Wakame::AdministratorCommandRunner
  class CommandArgumentError < StandardError; end

  attr_reader :options, :sub_options, :tmp_args

  def initialize(args)
    @args = args.dup
    @options = {
      :command_server_uri => Wakame.config.drb_command_server_uri
    }
    @sub_options = {}
    @tmp_args = nil
  end

  SUB_COMMANDS = {
    'status' => {:opt_parser => lambda { |parser|
      }},
    'action_status' => {:opt_parser => lambda { |parser|
      }},
    'launch_cluster' => {},
    'shutdown_cluster'=> {},
    'propagate_service'=> {
      :opt_parser => lambda { |parser|  },
      :left_parser => proc {
        raise CommandArgumentError, "Property name has to be given " if tmp_args.size < 1
        sub_options[:prop_name] = tmp_args.shift
      }
    },
    'migrate_service'=> {
      :opt_parser => lambda { |parser|  },
      :left_parser => proc {
        raise CommandArgumentError, "Service instance ID has to be given " if tmp_args.size < 1
        sub_options[:service_instance_id] = tmp_args.shift
        if tmp_args.size == 1
          sub_options[:agent_id] = tmp_args.shift
        end
      }
    },
    'deploy_config' => {
    }
  }


  def parse(args=@args)
    @tmp_args = args.dup

    comm_parser = OptionParser.new { |opts|
      opts.banner = "Usage: wakameadm [options] command [options]"
      
      opts.separator ""
      opts.separator "options:"
      opts.on( "-s", "--server DrbURI", "command server" ) {|str| @options[:command_server_uri] = str }
    }


    comm_parser.order!(@tmp_args)
    @options.freeze
    parse_sub_command
    @sub_options.freeze
  end
  


  def run
    parse

    cmd = DRbObject.new_with_uri(@options[:command_server_uri])

    case @subcmd
    when 'launch_cluster'
      cmd.launch_cluster
    when 'shutdown_cluster'
      cmd.shutdown_cluster
    when 'propagate_service'
      cmd.propagate_service(@sub_options[:prop_name])
    when 'migrate_service'
      cmd.migrate_service(@sub_options[:service_instance_id], @sub_options[:agent_id])
    when 'deploy_config'
      cmd.deploy_config
    when 'status'
      res = cmd.status
      print_status(res)
    when 'action_status'
      res = cmd.action_status
      print_action_status(res)
    end

  end

  private

  def parse_sub_command
    @subcmd = @tmp_args.shift
    
    fail "no such sub command: #{@subcmd}" unless SUB_COMMANDS.has_key? @subcmd
    
    opt_parser = SUB_COMMANDS[@subcmd][:opt_parser]
    if opt_parser
      sub_parser = OptionParser.new &opt_parser
      sub_parser.order!(@tmp_args)
    end

    left_parser = SUB_COMMANDS[@subcmd][:left_parser]
    if left_parser
      begin
        instance_eval(&left_parser)
      rescue CommandArgumentError => e
        fail e
      end
    end
  end

  def _block_caller(args, &blk)
    yield args
  end

  STATUS_TMPL =<<__E__
Cluster : <%= cluster[:name].to_s %> (<%= cluster[:status].to_s %>)
<%- cluster[:properties].each { |prop, v| -%>
  <%= v[:type].to_s %> : <min=<%= v[:min_instance] %>, max=<%= v[:max_instance] %>, type=<%= v[:instance_counter_class].split('::').last %>> 
  <%- v[:instances].each { |id|
         svc_inst = cluster[:instances][id]
  -%>
     <%= svc_inst[:instance_id] %> (<%= trans_svc_status(svc_inst[:status]) %>)
  <%- } -%>
<%- } -%>
<%- if cluster[:instances].size > 0  -%>

Instances :
  <%- cluster[:instances].each { |k, v| -%>
  <%= v[:instance_id] %> : <%= v[:property] %> (<%= trans_svc_status(v[:status]) %>)
    <%- if v[:agent_id ] -%>
    On VM instance: <%= v[:agent_id ]%>
    <%- end -%>
  <%- } -%>
<%- end -%>
<%- if agent_monitor[:agents].size > 0 -%>

Agents :
  <%- agent_monitor[:agents].each { |a| -%>
  <%= a[:agent_id] %> : <%= a[:attr][:local_ipv4] %>, <%= a[:attr][:public_ipv4] %> load=<%= a[:attr][:uptime] %>, <%= (Time.now - a[:last_ping_at]).to_i %> sec(s) (<%= a[:status] %>)
    <%- if a[:services].size > 0 -%>
    Services (<%= a[:services].size %>): <%= a[:services].collect{|id| cluster[:instances][id][:property] }.join(', ') %>
    <%- end -%>
  <%- } -%>
<%- end -%>
__E__

  SVC_STATUS_MSG={
    Wakame::Service::STATUS_OFFLINE=>'Offline',
    Wakame::Service::STATUS_ONLINE=>'ONLINE',
    Wakame::Service::STATUS_UNKNOWN=>'Unknown',
    Wakame::Service::STATUS_FAIL=>'Fail',
    Wakame::Service::STATUS_STARTING=>'Starting...',
    Wakame::Service::STATUS_STOPPING=>'Stopping...',
    Wakame::Service::STATUS_RELOADING=>'Reloading...',
    Wakame::Service::STATUS_MIGRATING=>'Migrating...',
  }
  def trans_svc_status(stat)
    SVC_STATUS_MSG[stat]
  end

  def print_status(status)
    sc = cluster = status[:service_cluster]
    agent_monitor = status[:agent_monitor]
    puts ERB.new(STATUS_TMPL, nil, '-').result(binding)
  end

  ACTION_STATUS_TMPL=<<__E__
Running Actions : <%= status.size %> action(s)
<%- if status.size > 0 -%>
<%- status.each { |id, j| -%>
JOB <%= id %> :
  start : <%= j[:created_at] %>
  <%= tree_subactions(j[:root_action]) %>
<%- } -%>
<%- end -%>
__E__


  def print_action_status(status)
    puts ERB.new(ACTION_STATUS_TMPL, nil, '-').result(binding)
  end


  def tree_subactions(root, level=0)
    str= ("  " * level) + "#{root[:type]} (#{root[:status]})"
    unless root[:subactions].nil?
      root[:subactions].each { |a|
        str << "\n  "
        str << tree_subactions(a, level + 1)
      }
    end
    str
  end

end



Wakame::AdministratorCommandRunner.new(ARGV).run
