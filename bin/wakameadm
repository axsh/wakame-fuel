#!/usr/bin/env ruby

require File.dirname(__FILE__) + '/../config/boot'

require 'rubygems'
require 'optparse'
require 'drb/drb'

require 'erb'

require 'wakame'
require 'wakame/util'

class Wakame::AdministratorCommandRunner
  class CommandArgumentError < StandardError; end

  attr_reader :options, :sub_options, :tmp_args

  def initialize(args)
    @args = args.dup
    @options = {
      :command_server_uri => Wakame.config.drb_command_server_uri
    }
    @sub_options = {}
    @tmp_args = nil
  end

  SUB_COMMANDS = {
    'status' => {:opt_parser => lambda { |parser|
      }},
    'action_status' => {:opt_parser => lambda { |parser|
      }},
    'launch_cluster' => {},
    'shutdown_cluster'=> {},
    'propagate_service'=> {
      :opt_parser => lambda { |parser|  },
      :left_parser => proc {
        raise CommandArgumentError, "Property name has to be given " if tmp_args.size < 1
        sub_options[:prop_name] = tmp_args.shift
      }
    },
    'deploy_config' => {
    }
  }


  def parse(args=@args)
    @tmp_args = args.dup

    comm_parser = OptionParser.new { |opts|
      opts.banner = "Usage: wakameadm [options] command [options]"
      
      opts.separator ""
      opts.separator "options:"
      opts.on( "-s", "--server DrbURI", "command server" ) {|str| @options[:command_server_uri] = str }
    }


    comm_parser.order!(@tmp_args)
    @options.freeze
    parse_sub_command
    @sub_options.freeze
  end
  


  def run
    parse

    cmd = DRbObject.new_with_uri(@options[:command_server_uri])

    case @subcmd
    when 'launch_cluster'
      cmd.launch_cluster
    when 'shutdown_cluster'
      cmd.shutdown_cluster
    when 'propagate_service'
      cmd.propagate_service(@sub_options[:prop_name])
    when 'deploy_config'
      cmd.deploy_config
    when 'status'
      res = cmd.status
      print_status(res)
    when 'action_status'
      res = cmd.action_status
      print_action_status(res)
    end

  end

  private

  def parse_sub_command
    @subcmd = @tmp_args.shift
    
    fail "no such sub command: #{@subcmd}" unless SUB_COMMANDS.has_key? @subcmd
    
    opt_parser = SUB_COMMANDS[@subcmd][:opt_parser]
    if opt_parser
      sub_parser = OptionParser.new &opt_parser
      sub_parser.order!(@tmp_args)
    end

    left_parser = SUB_COMMANDS[@subcmd][:left_parser]
    if left_parser
      begin
        instance_eval(&left_parser)
      rescue CommandArgumentError => e
        fail e
      end
    end
  end

  def _block_caller(args, &blk)
    yield args
  end

  STATUS_TMPL =<<__E__
Cluster : <%= cluster[:name].to_s %> (<%= cluster[:status].to_s %>)
<%- cluster[:properties].each { |v| -%>
  <%= v[:type].to_s %> : <min=<%= v[:min_instance] %>, max=<%= v[:max_instance] %>>
  <%- unless v[:instances].empty? -%>
  <%- v[:instances].each { |s| -%>
     <%= s[:instance_id] %> (<%= s[:status] %>)
  <%- } -%>
  <%- end -%>
<%- } -%>
<%- unless cluster[:instances].empty?  -%>

Instances :
  <%- cluster[:instances].each { |k, v| -%>
  <%= v[:instance_id] %> : <%= v[:property] %> (<%= v[:status] %>)
  <%- } -%>
<%- end -%>
<%- unless agent_monitor[:agents].empty? -%>

Agents :
  <%- agent_monitor[:agents].each { |a| -%>
  <%= a[:agent_id] %> : <%= a[:attr][:local_ipv4] %>, <%= a[:attr][:public_ipv4] %> load=<%= a[:attr][:uptime] %>, <%= (Time.now - a[:last_ping_at]).to_i %> sec(s) (<%= a[:status] %>)
  <%- } -%>
<%- end -%>
__E__

  def print_status(status)
    sc = cluster = status[:service_cluster]
    agent_monitor = status[:agent_monitor]
    puts ERB.new(STATUS_TMPL, nil, '-').result(binding)
  end

  ACTION_STATUS_TMPL=<<__E__
Running Actions : <%= status.size %> action(s)
<%- if status.size > 0 -%>
<%- status.each { |id, j| -%>
  JOB <%= id %> :
    start : <%= j[:created_at] %>
    <%- j[:actions].each { |a| -%>
    <%= a[:type] %> (<%= a[:status] %>)
    <%- } -%>
<%- } -%>
<%- end -%>
__E__


  def print_action_status(status)
    puts ERB.new(ACTION_STATUS_TMPL, nil, '-').result(binding)
  end
  
end



Wakame::AdministratorCommandRunner.new(ARGV).run
